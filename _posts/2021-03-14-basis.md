---
layout: post
title: java基础进阶回顾2
categories: Java
description: java基础进阶2
keywords: Java
---

# 1、集合Collection

集合是一个容器

不能存储基本数据类型，存储的是对象的内存地址

对象要重写equals方法

存储的数据类型随意，但是加<xxx>会约束存储的数据类型只能是xxx。称作**泛型**

取数据：

	- 调用迭代器Iterator，遍历集合数据
	- foreach【增强for循环】



#### 常用方法

​		add(xxx);添加元素【实际上放入的是Integer类型数据的内存地址，自动装箱】

​		size();获取元素个数

​		clear();清空集合

​		contains(xxx);判断是否含有xxx元素【返回true或false】

​		remove(xxx);删除xxx元素

​		isEmpty();判断集合是否为空【返回true或false】

​		toArray();集合转换成数组【了解】



**迭代器iterator**：遍历集合

```java
//获取迭代器对象，c为集合对象
Iterator it = c.Iterator();
while(it.hasNext){
    Object obj = it.next();
    System.out.println(obj);
}

```





## 1.1 List集合

​		有序，可重复【有下标】



**特有方法**：

​		add(下标，元素)；在指定下标插入元素，后面的元素往后位移【效率低】

​		set(下标)；修改指定下标的元素

​		get(下标)；获取指定下标的元素

​		indexOf(xxx);获取xxx元素第一次出现的索引

​		lastIndexOf(xxx);最后出现的下标

​		remove(下标)；删除指定下标的元素



### 常用类

- ArrayList：底层是数组

  ​	默认创建长度为0的数组，当添加第一个元素时，初始化容量为10





- LinkedList：底层双向链表

  ​	增删快，检索慢



- Vector(了解)

。



## 1.2 Set集合

​		无序，不可重复

​		底层是Map集合，向set集合中放数据，实际上是放入了Map集合的key部分

### 常用类

- hashSet：底层哈希表



- treeSet：底层二叉树







# 2、图Map

​		存储<key,value>键值对

​		key无序不可重复

### 常用方法

​		clear();清空

​		isEmpty();判断是否为空

​		containsKey(key);判断key是否存在

​		containsValue(value);判断value是否存在



​		size();元素的个数

​		put(key,value);存数据

​		get(key);根据key获取value

​		keySet();获得所有key，形成set集合

​		values();获得所有value

​		entrySet();获得的数据类型为"**Map.Entry**<key,value>",**Map.Entry是静态内部类**



遍历Map集合

- 通过keySet获得所有的key，使用迭代器Iterator遍历
- 获取key，使用foreach遍历
- 通过entrySet()方法，将Map集合转换成Set集合，遍历Set集合【set集合的数据类型为Map.Entry<key,value> 】





### 常用类

- HashMap

  ​	哈希表，底层是数组和单向链表的结合。

  ​		{【哈希值，key，value，下一个链表地址】，

  ​			【哈希值，key，value，下一个链表地址】，

  ​			【哈希值，key，value，下一个链表地址】

  ​			}

  哈希值可用通过哈希算法转换成数组的下标

  ​	

  ![image-20210314103416676](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210314103416676.png)

  通过key求出的哈希值全都不一样，那就会散列分布不均匀，就变成一维数组了，所以要重写hashcode()方法和equals()方法

  ​		--在jid8之后，如果单向链表中元素超过8个，单向链表会转换成红黑树，当少于6个时，会重新转换成单向链表。



- TreeMap

  ​	TreeSet集合等同于TreeMap的key部分

  ​	无序不可重复，但可按照大小排序【放进去是无序的，但取出时key部分按大小排序】

  ​	自己定义的类要用比较器排序

  ​	

  ​		

- hashtable（了解）

  ​	properties配置文件

  ​		key和vlue都是String类型

  ​		存：setProperty("key","value");

  ​		取：getProperty("key");



### 比较器

​		1、集合中的类要实现Comparable接口，重写compareTo方法，在方法中写比较规则

​		2、*单独创建个类实现Comparator接口，在开始创建集合中类的对象时，传进去这个比较器对象*





# 3、I/O流（常用16个）



文件输入和输出

​	读文件【输入】要关闭：close();

​	写文件【输出】要刷新：flush();

| 文件专属         | 转换流             | 缓冲流             | 标准输出流  | 数据专属流       | 对象专属流         |
| ---------------- | ------------------ | ------------------ | ----------- | ---------------- | ------------------ |
| FileInputStream  | InputStreamReader  | BufferInputStream  |             | DataInputStream  | ObjectInputStream  |
| FileOutputStream | OutputStreamWriter | BufferOutputStream | PrintStream | DataOutputStream | ObjectOutputStream |
| FileReader       |                    | BufferReader       |             |                  |                    |
| FileWriter       |                    | BufferWriter       | PrintWriter |                  |                    |



## FileInputStream方法

​		read();读取一个字节

​		read(byte数组对象)；将数据读到byte数组中，返回读取到的个数，读完返回-1

​		available();还剩几个字节没有读，返回未读的数量，**可以获得文件全部的字节数量**

​		skip(4);跳过四个字节

```java
FileInputStream fis = null;
try{
    fis = new FileInputStream("文件路径");
    
   /* 
    //read()方法，一次读一个字节，读一个自动后移一位，读完返回-1【不常用】
    int readDate = 0;
    while((readDate = fis.read()) != -1){
        System.out.print(readDate);
        }
       */ 
        
        
    byte[] bytes = new byte[10];
    int readCount = 0;
    //read(byte数组对象)；方法返回读到的字节个数，读完返回-1
    while((readCount = fis.read(bytes)) !=-1){
        
        System.out.print(new String(bytes,0,readCount));
        
    }
    
    
}catch(){}

finally(fis != null){
    try{
          fils.close();  
    }catch(){}
}
```

## FileOutputStream方法

​		write(byte数组);

​		write(byte数组，起始下标，个数)；

```java
FileOutputStream fos = null;
try{
    //没有文件会创建，有文件会清空文件中的内容
    fos = new FileOutputStream("文件路径");
    //不删除文件中内容，追加的方式写入
    //fos = new FileOutputStream("文件路径",true);
     
        
    byte[] bytes = [10，11，12，13];
    
    fos.write(bytes);
    //fos.write(bytes,0,2);
    
    //将数据刷入文件
    fos.flush();
}catch(){}

finally(fis != null){
    try{
          fils.close();  
    }catch(){}
}
```





## BufferReader方法

​		自带缓冲区

readLine();读一行，返回这一行字符串，读完返回一个null【不带换行符，需要使用println换行】

```java
//FileReader作为节点流
FileReader reader = new FileReader("文件地址");

//构造方法需要传递一个FileReader对象
//BufferReader作为包装流
BufferReader br = new BufferReader(reader);

String s = null;
if((s = br.readLine()) != null){
    System.out.println(s);
}


//关闭时只需要关闭包装流，里面的节点流会自动关闭
br.close();
```





## DataOutputStream数据专属流



会将数据和数据的类型一并写入文件，这个文件不是普通的文本文档

只能使用DataInputStream读，并且读的顺序和写的顺序要一致





## 标准输出流

PrintStream：不需要关闭，会自动关闭

 ```java
//联合写
System.out.println("xxx");

//分开写
PrintStream ps = new System.out;
ps.println("xxx");


//改变输入方向
//将要输出的数据通过文件输出流输出到文件中，不再输出到控制台【打印日志文件的框架的原理】
PrintStream pr = new PrintStream(new FileOutStream("log",true));
System.setOut(pr);

 ```



## 对象专属流（序列化和反序列化）



序列化版本号：如果没写，系统会默认提供，可以用来区分 类。

​		【不同的人编写的同样的类，但这两个类确实不是同一个类】	

​		【一个类，生成序列化版本号之后，在更改部分代码后会生成全新的序列化版本号】

​		【同一个类，更改代码后被认为是不同的类，所以建议手动写序列化版本号】

```java
//自定义序列化版本号
private static final long serialVersion UID = 1L;
```



ObjectOutputStream：序列化【Serialize】

​		将java对象切成一块一块的，编上号，存到文件当中



​	同时序列化多个对象：

​		将多个对象实现Serialize接口，放入集合中，然后序列化这个集合



**用transient修饰的属性不参与序列化操作**，反序列化时，被设为初始值



```java
Student st = new Student(20,"xxx");

//对象序列化存储位置
ObjectOutputStream oos = new ObjectOutpitStream(new FileOutputStream("xxx"));
//序列化对象
oos.writeObject(st);


//对象需要实现Serializable接口，使对象变成可序列化的
public void Studendt implements Seralizable{
    
    //用transient修饰的属性不参与序列化操作
    private transient int age;
    
    private String name;
    public Student(int age,String name){
        this.age = age;
        this.name = name;
    }
    
    	setxxx
        getxxx
        toStringxxx
}

```



ObjectInputStream：反序列化【DeSerialize】

​		将硬盘中的数据恢复到内存中，恢复组装成java对象

```java
//获得序列化文件
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("xxx"));
//反序列化，读出对象
Object obj = ois.read();
```



# 4、File类

**文件和目录路径名的抽象表示形式**，不能进行数据读写

## 方法

```java
FIle f = new File("xxx");//创建一个File对象


//判断文件是否存在
if(f.exists()){
    f.creatNewFile();//以文件形式新建
    f.mkdir();//以目录形式新建
    f.mkdirs();//以多重目录形式新建
}
    
    String ff = f.getParent();//获取文件的父路径
    File fff = f.getParentFile();
    f.getAbsolutePath();//获取绝对路径 

f.getName();//获取文件名

f.isFile();//判断是否是文件
f.isDirectory();//判断是否是路径

long haomiao = f.lastModified();//获取文件最后一次修改的时间【从1970年1月1日至今的毫秒】
f.length();//获取文件大小

File[] files = f.listFiles();//或取当前文件下的所有子文件
```



File和IO流组合可以进行文件复制



# 5、线程

## 5.1 线程实现

编写一个类，继承Thread，重写run方法

```java

{public static void main(String[] args){
    MyThread myThread = new MyThread();
    MyThread myThread2 = new MyThread();
    //start方法，启动一个分支线程，启动线程之后，瞬间就结束了
    myThread.start();
    myThread2.start();
}

}


class MyThread extends Thread{
    public void run(){
        //运行的程序
        
    }
}
```



编写一个类，实现Runnable接口， 但这个类并不是线程

  ```java
{public static void main(String[] args){
    //创建一个可运行的对象
    MyRunnable mr = new MyRunnable();
    //将可运行的对象封装称线程对象
    Thread myThread = new Thread(mr);

    myThread.start();
}

}

//这并不是一个线程
class MyRunnable implement Runnable{
    public void run(){
        //运行的程序
        
    }
}
  ```

## 5.2 线程生命周期



![image-20210314182158000](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210314182158000.png)



## 5.3 线程操作



获取当前线程对象【写在main方法中，获取的是main方法线程对象；写在子线程中，运行时获取的是子线程对象】

静态方法：currentThread();

```java
Thread t = Thread.currentThread();
```



设置线程名字

```java
t.setName("xxx");//一个线程默认名字为：Thread-0
```



获取线程名字

```java
String st = t.getName();
```



sleep方法：**静态方法**，参数是毫秒，让**当前线程**休眠

​		可以做到间隔特定的时间，执行特定的代码

```java
Thread.sleep(1000);//当前线程休眠【阻塞】1000毫秒
```



唤醒interrupt();依靠的是异常的处理机制【使用此方法会让睡眠线程的睡眠方法出异常，进入到catch，结束睡眠】

```java
t.interrupt();//终止t线程的休眠，唤醒t线程
```



强行终止线程stop();

 ```java
t.stop();//已过时，不建议使用
 ```

合理终止

```java
Runnable r = new MyThread();
Thread t = new Thread(r);
t.start();


//合理终止线程:将布尔标记的值变为false；使线程进入else，执行return终止
r.runner = false;


class MyThread extends Runnable{
    //打个布尔标记
    boolean runner = true;
    
    if(runner){
        xxxx;
    }else{
        //终止线程
        return;
    }
}
```





## 5.4 线程安全

什么时候会产生线程安全问题？

	- 多线程并发
	- 有共享数据
	- 共享数据有修改的行为

怎么解决？

​		线程同步机制，排队执行。

​			实例方法锁，是对象级别的

​			静态方法锁，是类级别的

 ```java
//同步写在具体操作的代码块上
synchronized(需要同步的共享对象){
    //需要同步操作的，操作共享数据的代码块
}


//同步写在实例方法体上
//线程运行同一个对象的方法时，会等待排队
public synchronized void useCount(){
    
}


//同步写在静态方法上
//静态方法不能创建多个，所以只能有一个，是类级别的
//类锁，排他锁，即使创建了一百个对象，锁也只有一把
//线程运行同一个类的不同对象也要等待排队

 ```





































# 6、反射

