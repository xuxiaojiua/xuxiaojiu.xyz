---
layout: post
title: java学习web基础回顾
categories: Java
description: Java学习web基础回顾
keywords: Java
---

#  javaweb复习

Tomcat

servlet

Jsp



# 1、Tomcat



启动与关闭

​			bin/startup.bat

​				/shutdown.bat

访问测试：http://localhost:8080/









# 2、Servlet

## Servlet接口实现类开发步骤

```java
	- 创建java类继承HttpServlet，使之成为Servlet接口的实现类
	- 重写doGet或doPost方法
	- 将Servlet实现类信息注册到Tomcat服务器【web.xml】
```

```xml
<servlet>
    <servlet-name>xxx</servlet-name>
    <servlet-class>类路径</servlet-class>
</servlet>
<servlet-mapping>
    <servlet>xxx</servlet>
    <url-pattern>简短别名</url-pattern>
</servlet-mapping>
```



## Servlet对象生命周期

一个Servlet对象在服务器运行期间只能创建一个Servlet实例对象



## HttpServletResponse接口

执行结构写到响应体



设置响应头，告诉浏览器读取响应数据的方式【text形式或html形式】

```java
resp.setContentType("text/html;charset=utf-8");

//将xxx输出到网页
PrintWriter out = resp.getWriter();
out.print(xxx);
```

设置响应头的location属性【改变地址栏网址】【重定向】

```java
resp.sentRedirect("网址");
```

## HttpServletRequest接口

读取请求行中信息

```java
//读取请求行中URL信息
req.getRequestURL().toString();
//读取请求方法
req.getMethod();
//读取URI信息【资源文件地址：/网站名/资源文件名】
req.getRequestURI();
```

读取请求头或请求体中的请求参数

  - 以get方式发送，数据保存在请求头中，tomcat服务器会自动以"utf-8"解码

  - 以post方式发送，数据保存在请求体中，由当前对象request解码，中文会乱码

    ​	-- 需要手动设置解码方式：req.setCharacterEncoding("utf-8");

```java
//得到请求参数名，保存到枚举对象中
req.getParameterName();
//通过请求参数获得请求值
req.getParameter("");
```

代替浏览器向http服务器申请资源文件调用



## 默认欢迎页面

```xml
<welcome-file-list>
	<welcome-file>index.html</welcome-file>
    <welcome-file>index.jsp</welcome-file>
</welcome-file-list>
```

## 转发和重定向

【浏览器一次只能发起一次Servlet请求，但经常需要多个Servlet协同工作】

 ```java
//重定向,网页跳转
resp.sendRedirect("地址");


//请求转发
//由srevlet对象代替网页向服务器发起请求
//生成请求对象
RequestDispather report = req.getRequestDispatcher("/资源文件名");
//将请求发送给tomcat
report.forward(request,response);
 ```

# 3、数据共享



## ServletContext接口

​	全局作用域对象

​		- 服务器启动时自动创建

​		- 一个网站只有一个

​		- 服务器关闭时销毁

```java
//向服务器请求获得全局作用域对象
ServletContext application = request.getServletContext();

//向作用域中放数据【类似一个Map】
application.setAttribute("key",value);


//取数据
//先获得作用域对象
ServletContext application = request.getServletContext();
Object obj = application.getAttribute("key");
```





## Cookie

一个网站的同一个浏览器/用户，作为身份认证【会员卡】

在java中被作为一个类来处理

**只能存放String类型的数据**

保存在客户端

​		- 默认存储在浏览器缓存中，**浏览器关闭，Cookie清除**

​		- 可以手动为Cookie设置存活时间，将会保存到硬盘中

```java
//创建Cookie
Cookie cookie1 = new Cookie("key1","value1");
Cookie cookie2 = new Cookie("key2","value2");

//设置在硬盘存活时间【秒】
cookie1.setMaxAge(60);
//Cookie中可放入多个
//发送给浏览器客户端
resp.addCookie(cookie1);
resp.addCookie(cookie2);



//获得Cookie
Cookie[] cookies = req.getCookies();
```

## HttpSession接口

保存会话状态，存放在服务器端内存中【私人储物柜,购物车】

在浏览器发送请求时，服务器会自动创建一个Session编号，发送给浏览器一个Cookie【Cookie : JSessionID=Session编号】

浏览器再次请求Session会匹配Cookie判断是哪一个关联的Session

打开浏览器，发送多个请求，直到关闭浏览器，表示一次完整的会话

可存放任意类型的数据【Object】

**使用Map集合存放数据，可以存储任意数量数据**



```java
//向服务器请求Session，自动创建一个Session编号，发送给浏览器一个Cookie【Cookie : JSessionID=Session编号】
HttpSession session = request.getSession();
//放数据，放到Session域中
session.setAttribute("key1",value1);




//浏览器发送请求，在另一个网页取数据
//请求得到Session【会匹配Cookie，判断是哪一个Session】
HttpSession session = request.getSession();
//取数据
Object obj = session.getAttribute("key1");
```

Session对象什么时候销毁

​		在浏览器关闭时，用户的Cookie会被清除，与Cookie关联的Session并不能知道浏览器是否被关闭

​		在下次打开浏览器访问时，是不同的Cookie

​		Session在一段时间无人访问，web服务器会回收Session对象

​		可在web.xml配置超时时间【默认是30分钟】

```xml
<session-config>
    <session-timeout>120</session-timeout><!--分钟-->
</session-config>
```



```java
//req.getSeeion()和req.getSession(false);
//获取当前Session，如果没有则自动创建一个
req.getSession();

//如果没有返回NULL，在操作数据前，可验证用户登录
//验证不通过，安全退出
HttpSession session = req.getSession(false);
if(session != null){
    //销毁Session
    session.invalidate();
}

```



## HttpServletRequest

请求转发时，在两个Servlet之间共享数据

```java
//将共享数据放入request中
req.setAttribute("key1",value1);
//请求转发,将数据交给下一个Servlet，由下一个Servlet处理并返回结果
req.getRequestDispather("/xxxServlet").foward(req,resp);


//由另一个Servlet接收数据
Object obj = req.getAttribute("key1");
```

# 4、监听器和过滤器

## 监听器

一组Servlet规范中的接口，共有八个

用来监控**作用域对象**创建与销毁，共享数据的变化【添加，删除，修改】



作用域对象

  - ServletContext 		全局作用域
  - HttpSession		会话作用域
  - HttpServletRequest 请求作用域



实现步骤

```java
	- 根据监听需求，选择对应的监听器接口进行实现
	- 重写监听器方法
	- 在web.xml中将监听器实现类注册到服务器
```

|      | 对象的监控             | 共享数据的监控                  |          |
| ---- | ---------------------- | ------------------------------- | -------- |
| 全局 | ServletContextListener | ServletContextAttributeListener | 需要注册 |
| 会话 | HttpSessionListener    | HttpSessionAttributeListener    | 需要注册 |
| 请求 | ServletRequestListener | ServletRequestAttributeListener | 需要注册 |



| 监测实体类对象添加到Session或从Session中删除 | 监听实体类对象钝化与活化【内存到硬盘与硬盘到内存】 |
| -------------------------------------------- | -------------------------------------------------- |
| HttpSessionBindingListener                   | HttpSessionActivationListener                      |

## 过滤器

Filter接口，由开发人员提供，服务器不负责提供

作用

```java
	- 在Http服务器调用资源文件之前，拦截请求，检测请求的合法性，对请求进行增强
```



实现步骤

  - 创建java类实现Filter接口
  - 重写doFilter接口

```java
//将请求放行到下一个资源
filterChain.doFilter(request,response);
```

  - 在web.xml注册

```xml
<!--将过滤器类文件路径交给服务器-->
<filter>
    <filter-name>xxx</filter-name>
    <filter-class>类文件路径</filter-class>
</filter>
<!--通知服务器在调用何种资源文件时使用过滤器-->
<filter-mapping>
    <filter-name>xxx</filter-name>
    <url-pattern>/资源文件</url-pattern>
</filter-mapping>
```

拦截器拦截的资源文件名设置

```xml
<url-pattern>/资源文件名</url-pattern>

<url-pattern>/包名/*</url-pattern>

<url-pattern>*.jpg</url-pattern>

<url-pattern>/*</url-pattern>
```



## 防止恶意登录

​		在登陆成功后，为用户创建一个Session

​		创建一个拦截器，拦截所有请求【登录页面的请求要放行】，在拦截器中判断Session是否为空【获取session使用：req.getSession(false)】，如果Session为空，就拒绝服务，重定向到登录页面；否则放行



![image-20210322192435024](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210322192435024.png)



# 5、文件上传和下载







# 6、 Jsp

JavaServlet Page

代替Servlet将响应结果写入到响应体中

主要用来做页面展示

**是一种特殊的Servlet**



## 执行原理

Tomcat内置了jsp翻译引擎，将jsp文件翻译为java文件，然后编译生成.class文件

【将index.jsp文件翻译成index_jsp.java，在编译为index_jsp.class】

【生成的java文件就是一个Servlet的实现类】



## Jsp基础语法

注释

```jsp
<%-- 注释 --%>
```

执行标记

```jsp
<%  	//jsp的执行标记
		//写在此处的代码，相当于写在Servlet的方法中
		int a = 100;		
%>
```

声明标记

```jsp
<%!
    //写在此处的代码，相当于写在Servlet类中，doGet和doPost方法的外面
    静态变量；
    实例变量；
    方法。。。
%>
```



输出标记

```jsp
<%--
    使用<%= %>可以输出java代码中的数据,等同于Servlet中的：out.print();
--%>


<%= a %>
```

## 常用内置对象

**request	session	application	pageContext**

*jsp已经自动向服务器申请，可以直接使用*

*【一共有九个内置对象】*



pageContext是指当前Jsp文件的作用域，数据仅能在当前Jsp文件中共享【Jsp独有的，主要用于JSTL标签与Jsp文件之间共享数据】



## Jsp和Servlet分工

```java
	- servlet进行数据处理并得到结果
	- Servlet将处理结果放入request请求作用域对象中，通过请求转发，转到Jsp中
	- Jsp从请求作用域中得到结果，进行页面展示
```







## EL工具包

降低Jsp文件开发时java命令开发强度【Tomcat服务器自带了】



### EL表达式

```java
	- 取代Jsp文件中的java代码
	- 从作用域中读取指定的共享数据，并输出
```

```jsp
<%
	String str = (String) 作用域对象.getAttribute("共享数据");
%>
<%=str%>



${作用域对象别名.共享数据}
```



**作用域别名**

| Jsp对象     | EL表达式取数据                 |
| ----------- | ------------------------------ |
| application | ${applicationScope.共享数据名} |
| session     | ${sessionScope.共享数据名}     |
| request     | ${requestScope.共享数据名}     |
| pageContext | ${pageScope.共享数据名}        |



**EL简化**

​		${共享数据名}

【在使用时，如果四个作用域中没有同名数据，可以省略；如果有同名数据，会按照从小到大的共享范围取数据】

应用场景：简化从pageContext 作用域中获得共享数据



**EL表达式支持运算符**

  - 数学运算
  - 关系运算：<、=，>，<=，>=，！=
		- 逻辑运算：&&，||，！
		- if判断：xx?xx:xx



**EL表达式内置对象**【了解】

​		${param.请求参数名}【等同于Servlet中的：request.getParameter("请求参数名");】

​		${paramValues.请求参数名[下标]}【等同于：String[] values = request.getParameter("请求参数名");】

​				请求参数在请求包中以数组形式存在：xxx/index.jsp?key=value1&key=value2&key=value3
