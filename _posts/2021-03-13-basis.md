---
layout: post
title: java基础进阶回顾
categories: Java
description: Java学习进阶回顾
keywords: Java
---

# java学习进阶回顾

## 1、 final

​		final修饰的变量通常加上static修饰，称为常量

​		一般是公开的

​		常量名建议全部大写，每个单词之间用下划线衔接

```java
public static final int COUNT = 10;
```



【了解】

- final修饰的类无法被继承

- final修饰的方法无法被覆盖

- final修饰的实例变量，必须手动赋值，不会采用系统默认值

- final修饰的局部变量只能赋一次值，不能重新赋值



## 2、 抽象类abstract

​		不能创建对象，但有构造方法

​		抽象类中不一定有抽象方法，可以有非抽象方法

​		抽象方法：没有方法体，只能在抽象类中

​		**没有方法体，不一定是抽象方法，底层调用的C++动态链接库也可以没有方法体，方法的修饰符是native**



```java
[修饰符列表] abstract class A{
    public abstract void doSome();
}
```

​		非抽象类继承抽象类，必须将抽象方法实现

## 3、 接口

​		完全抽象的，特殊的抽象类，一个类可以实现多个接口，一个接口可以继承多个接口

​		无构造方法

​		**只有常量和抽象方法**

​		方法public abstract可以省略

​		常量的public static final可以省略

​		extends和implement可以同时使用，extends在前，implement在后

```java
public interface A{
    int b();
    void c();
}
```







## 4、访问控制权限

范围：public > protected > 默认 >private

在哪可以使用：

- 属性：四个都能用
- 方法：四个都能用
- 类：public和默认能用
- 接口：public和默认能用

```java
//公共的，任何位置都可以访问
public int a;
//私有的，只能在本类访问
private int b;
//受保护的，可以在本类，同包，子类中访问
protected int c;
//默认，只能在本类，同包下访问
int d;

```



## 5、Object类

​		jdk类库的的根类：object类

​		String类重写了toSting和equals方法

### 5.1 toString

- 将对象转换称字符串形式，需要重写

### 5.2 equals

- 判断两个对象是否相等，默认比较的是内存地址，需要重写

### 5.3 hashcode

- 获取对象的哈希值

### 5.4 finalize

- 垃圾回收机制负责调用，重写后不需要程序员手动调用，如果希望在对象销毁时机执行一段代码，可以写到finalize()方法中
- System.gc();建议启动垃圾回收器

```java
//重写，不需要调用
protected void finalize() throws throwable{
    System.out.println("即将被销毁");
}
```

### 5.5 clone

- 负责对象克隆



## 6、 内部类

【了解】

匿名内部类

- 使用idea的快捷键alt + enter可自动实现

```java
//调用st对象的doSome方法
Student st = new Studnet();
//st.doSome(接口实现类对象，其他参数)；

//使用匿名内部类不需要将接口实现，直接new 接口{}

//st.doSome(new 接口(){},其他参数..)
//此接口的实现类没有名字
st.doSome(new 接口(){
    接口方法的实现
},其他参数..);
```



## 7、数组【一组数据】

​		一个容器，是存放相同类型数据的集合

​		长度一旦确定，不可变

​		数组扩容：新建个大数组，小数组数据拷入大数组【效率低】

优点：

- 可以存基本类型的数据，也可以存引用类型的数据
- 内存地址是连续的；检索，查找某个下标的元素效率高

缺点：

- 随机删除，增加元素效率低
- 不能存大容量数据，很难在内存上找到特别大的连续的内存空间

```java
//基本数据类型

//静态初始化
int[] array = {1,2,3};
// 动态初始化
int[] array1 = new int[5];

//引用数据类型
String[] array2 = xxx;
Person[] array3 = xxx;
```



所有的数组都有**length属性**

```java
//length是属性，不是方法
int a = array1.length;
```



#### 数组扩容

```java
System.arroycopy(拷贝源，拷贝源的起始下标，目标数组，目标起始下标，拷贝长度);
```



#### 二维数组

一维数组中的每个元素都是一维数组

```java
int[][] a = {
    			{1,2,3},
             	{4,5,6,0},
             	{7,8,9}
            }
```



#### 常用算法

数组工具类 ：**java.util.Arrays**

静态方法sort排序

```java
Arrays.sort(int数组);
```



#### 排序

- 冒泡排序：比较(n^2-n)/2次

```java
比较的数据：9 7 5 8 10
    第一次循环：冒出最大的10
    7 9 5 8 10 （9和7比较，交换位置）
    7 5 9 8 10 （9和5比较，交换位置）
    7 5 8 9 10 （9和8比较，交换位置）
    7 5 8 9 10 （9和10比较，不交换位置）
    第二次循环：冒出9
    5 7 8 9   10 （7和5比较，交换位置）
    5 7 8 9   10 （7和8比较，不交换位置）
    5 7 8 9   10 （8和9比较，不交换位置）
    第三次循环：冒出8
    5 7 8   9 10 （5和7比较，不交换位置）
    5 7 8   9 10 （7和8比较，不交换位置）
    第四次循环：冒泡7
    5 7   8 9 10 （5和7比较，不交换位置）
```



- 选择排序 ：比较(n^-n)/2次，但**交换次数少** 
- 原理：找出最小的，和第一个交换位置
- 实现：比较数据，找出最小的**数据的下标**，然后使用这个下标的数据和第一个数据交换位置

```java
比较的数据：9 7 5 8 10
    第一次循环结果：5和9交换位置
    5 7 9 8 10
    第二次循环结果：7不交换
    5   7 9 8 10
    第三次循环结果：8和9交换位置
    5 7   8 9 10
    第四次循环结果：不交换
    5 7 8   9 10
```



比冒泡排序效率高



#### 查找

一个一个找

二分法查找：在已经排序的基础上实现

```java
Arrays.binarySearch(数组对象，要查找的元素);//返回下标或者索引
```





## 8、 String类

### 构造方法

- String s = "xxx";
- String s = new String("xxx");
- String s = new String(char数组);
- String s = new String(char数组,起始下标,长度)；
- String s = new String(byte数组);
- String s = new String(byte数组,起始下标,长度);

 ```java
byte[] b = {97,98,99};

String st = new String(b);//abc
String st2 = new String(b,1,2);//bc,byte数组一部分转换成字符串

char[] c = {'我','是','谁'};
String st3 = new String(c);//我是谁
String st4 = new String(c,2,1);//谁
 ```



### 21种常用方法方法



charAt(下标)；【返回下标的值】



compareTo(); 字符串比较【返回值为int类型】

- -1或1：拿着两个字符串的第一个比较，能比出大小，后面就不比了
- 0：两个字符串相等

equals("xxx");判断两个字符串是否相等

equalsIgnoreCase("xxx");



contains(“xxx”);判断是否包含xxx【true或false】

startsWith("xxx");判断是否以xxx开始

endsWith("xxx");判断是否以xxx结尾【true或false】

isEmpty();判断是否为空串【true或false】



getBytes("xxxx");转换成byte数组【返回byte数组】

toCharArray();将字符串转换成char数组

toLowerCase();转换成小写

toUpperCase();转换成大写



**length()方法**判断数组长度



indexOf("xxx");xxx在字符串中第一次出现的下标

lastIndexOf("xxx");判断xxx在字符串中最后一次出现的下标



replace(newchar,oldchar);用newchar替换所有oldchar

split("-");将字符串以"-"拆分，返回String[]

subString(起始下标)；截取字符串

subString(起始下标，结束下标)；//不包含结束下标的字符



trim();去除字符串前后空白



**String st = String.valueOf(); String中唯一的静态方法：将非字符串转换成字符串**



### 字符串拼接

​		当频繁进行字符串拼接时

​		java的字符串是不可变的，每次拼接都会产生新的字符串，这样会占用大量的方法区内存。

​		使用”+“拼接，会产生很多冗余

 ```java
String a = "abc";
s += "def";
//以上两行代码会在方法区产生三个字符串对象：”abc“，”def“，”abcdef“
 ```



改进：

​		使用字符串缓冲区对象：StringBuffer,多线程下安全

```java
StringBuffer sb = new StringBuffer();
sb.append("xxx");//追加
```

​		底层时byte数组，初始化容量是16.



​		StringBuilder，多线程下不安全

```java
StringBuilder sb = new StringBuilder();
sp.append("xxx");
```



## 9、八种包装类

八种基本数据类型的包装类，都属于引用数据类型

在使用时，自动装箱、拆箱

| 基本数据类型 | byte | short | int     | long | float | double | boolean | char      |
| ------------ | ---- | ----- | ------- | ---- | ----- | ------ | ------- | --------- |
| 包装类       | Byte | Short | Integer | Long | Float | Double | Boolean | Character |



<img src="C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20210313141959827.png" alt="image-20210313141959827" style="zoom:50%;" />





## 10、日期类

```java
//获取时间
Date d = new Data();
//格式化容易看懂的日期
//yyyy 年
//MM 月
//dd 日
//hh 时
//mm 分
//ss 秒
//sss 毫秒
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss sss");
String noTime = sdf.format(d);
```

字符串转换成Date类型

```java
String time = "2021-03-13 00:00:00 000";
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd hh:mm:ss sss");
Date d = sdf.parse(time);
```



获取从1970-1-1 00：00：00 000到当前时间的毫秒数

```java
long times = System.currentTimeMillis();
```

可以统计方法执行时间





## 11、随机数

```java
Random r = new Random();
//随机返回int范围内的数字
int i = r.nextInt();
// 随机产生0~100的数字
int in = r.nextInt(101);
```





## 12、枚举

是一种引用数据类型

```java
//定义
//xxx为枚举类型名，SUCCESS和FAIL为枚举值
enum xxx{SUCCESS,FAIL}
//使用
xxx.SUCCESS;
XXX.FAIL;
```



## 13、异常

在java中以类和对象的型式存在

- 编译时异常

- 运行时异常

处理方式：

- 在方法声明时使用throws关键字抛给上一级
- 使用try... catch...进行异常捕捉

finally不能单独使用，和try...catch...同时使用，finally内代码必定执行，最后执行，当finally之前执行退出JVM，finally不执行

通常在finally中执行资源的关闭/释放





